package uk.co.froot.trezorjava.service;

import com.satoshilabs.trezor.lib.protobuf.TrezorMessageManagement;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import uk.co.froot.trezorjava.core.TrezorDeviceManager;
import uk.co.froot.trezorjava.service.fsm.ManagementFSM;
import uk.co.froot.trezorjava.service.fsm.specifications.WalletSpecification;
import uk.co.froot.trezorjava.service.fsm.states.BeginTestLoadWalletState;
import uk.co.froot.trezorjava.service.fsm.states.BeginWipeDeviceState;
import uk.co.froot.trezorjava.service.fsm.states.InitializedState;

/**
 * <p>Service to provide the following to application:</p>
 * <ul>
 * <li>TrezorServices entry point for downstream API consumers</li>
 * <li>Handles high level hardware wallet use cases (e.g. "create new wallet" etc)</li>
 * </ul>
 *
 * <p>Refer to the examples for how to correctly configure the service for use in downstream
 * consumer applications.</p>
 *
 * @since 0.0.1
 * Â 
 */
public class V2TrezorService implements TrezorService {

  private static final Logger log = LoggerFactory.getLogger(V2TrezorService.class);
  private final TrezorDeviceManager deviceManager;

  // Management state transitions
  private final ManagementFSM managementFSM;
  //private ManagementUseCase managementUseCase = ManagementUseCase.ATTACH_DEVICE_BEGIN;

  /**
   * @param deviceManager The Trezor device manager for low level communications.
   */
  public V2TrezorService(TrezorDeviceManager deviceManager) {
    this.deviceManager = deviceManager;
    managementFSM = new ManagementFSM(deviceManager);
  }

  /**
   * @return The Trezor device manager in use.
   */
  public TrezorDeviceManager getDeviceManager() {
    return deviceManager;
  }

  // Stateless messages

  @Override
  public void ping() {

    // A Ping can be sent in any state
    TrezorMessageManagement.Ping message = TrezorMessageManagement.Ping.newBuilder().setMessage("Pong!").build();
    deviceManager.sendMessage(message);

  }

  // Stateful messages

  @Override
  public void initialize() {

//    managementUseCase = ManagementUseCase.ATTACH_DEVICE_BEGIN;
    managementFSM.transitionTo(new InitializedState());

  }

  @Override
  public TrezorMessageManagement.Features features() {
    return deviceManager.context().getFeatures();
  }

  /**
   * <p>Cancel the current operation and return to the initialised state.</p>
   *
   * <p>This will trigger a SHOW_OPERATION_FAILED and a DEVICE_READY event during the reset phase.</p>
   *
   */
  public void cancel() {

    TrezorMessageManagement.Cancel message = TrezorMessageManagement.Cancel.newBuilder().build();
    deviceManager.sendMessage(message);

  }

  /**
   * <p>Clear the device back to factory settings.</p>
   */
  public void wipeDevice() {

    // Start the wipe device use case
    managementFSM.transitionTo(new BeginWipeDeviceState());

  }

//  /**
//   * <p>Change or remove the device PIN.</p>
//   *
//   * @param remove True if an existing PIN should be removed
//   */
//  public void changePIN(boolean remove) {
//
//    // Set the FSM context
//    context.beginChangePIN(remove);
//  }
//
//  /**
//   * <p>Initiate the process where the hardware wallet is first wiped then reset using its own entropy.</p>
//   * <p>This is the recommended method to use for creating a wallet securely.</p>
//   *
//   * @param language      The language (e.g. "english")
//   * @param label         The label to display below the logo (e.g "Fred")
//   * @param displayRandom True if the device should display the entropy generated by the device before asking for additional entropy
//   * @param pinProtection True if the device should use PIN protection
//   * @param strength      The number of bits in the seed phrase (128 bits = 12 words, 196 bits = 18 words, 256 bits = 24 words)
//   */
//  public void secureCreateWallet(
//    String language,
//    String label,
//    boolean displayRandom,
//    boolean pinProtection,
//    int strength
//  ) {
//
//    // Create the specification
//    CreateWalletSpecification specification = new CreateWalletSpecification(
//      language,
//      label,
//      displayRandom,
//      pinProtection,
//      strength
//    );
//
//    // Set the FSM context
//    context.beginCreateWallet(specification);
//
//  }
//
  /**
   * <p>Initiate the process where the hardware wallet is first wiped then loaded using an external seed phrase</p>
   * <h3>This is an insecure method for creating a wallet. DO NOT USE IN PRODUCTION.</h3>
   *
   * @param language   The language (e.g. "english").
   * @param seedPhrase The seed phrase provided by the user in the clear.
   * @param pin        The personal identification number (PIN) in the clear.
   */
  public void testLoadWallet(
    String language,
    String seedPhrase,
    String pin
  ) {

    // Create the specification
    WalletSpecification specification = new WalletSpecification(
      language,
      seedPhrase,
      pin
    );

    // Start the wipe device use case
    managementFSM.transitionTo(new BeginTestLoadWalletState());

  }
//
//  /**
//   * <p>Provide the user entered PIN</p>
//   *
//   * @param pin The PIN taken from the user ideally through an obfuscated PIN matrix approach
//   */
//  public void providePIN(String pin) {
//
//    // Use the FSM context to decide the appropriate continuation point
//    switch (context.getCurrentUseCase()) {
//      case DETACHED:
//        break;
//      case CREATE_WALLET:
//        context.continueCreateWallet_PIN(pin);
//        break;
//      case SIMPLE_SIGN_TX:
//        context.continueSignTx_PIN(pin);
//        break;
//      case SIGN_TX:
//        context.continueSignTx_PIN(pin);
//        break;
//      case REQUEST_PUBLIC_KEY:
//        context.continueGetPublicKeyUseCase_PIN(pin);
//        break;
//      case REQUEST_PUBLIC_KEY_FOR_IDENTITY:
//        context.continueGetPublicKeyForIdentityUseCase_PIN(pin);
//        break;
//      case REQUEST_DETERMINISTIC_HIERARCHY:
//        context.continueGetDeterministicHierarchyUseCase_PIN(pin);
//        break;
//      case REQUEST_CIPHER_KEY:
//        context.continueCipherKey_PIN(pin);
//        break;
//      case SIGN_MESSAGE:
//        context.continueSignMessage_PIN(pin);
//        break;
//      case CHANGE_PIN:
//        context.continueChangePIN_PIN(pin);
//        break;
//      case SIGN_IDENTITY:
//        context.continueSignIdentity_PIN(pin);
//        break;
//      default:
//        log.warn("Unknown PIN request use case: {}", context.getCurrentUseCase().name());
//    }
//  }
//
//  /**
//   * <p>Provide the user entered passphrase.</p>
//   *
//   * @param passphrase The passphrase taken from the user computer input
//   */
//  public void providePassphrase(String passphrase) {
//
//    // Use the FSM context to decide the appropriate continuation point
//    switch (context.getCurrentUseCase()) {
//      case DETACHED:
//        break;
//      case REQUEST_PUBLIC_KEY_FOR_IDENTITY:
//        context.continueGetPublicKeyForIdentityUseCase_Passphrase(passphrase);
//        break;
//      case SIGN_IDENTITY:
//        context.continueSignIdentity_Passphrase(passphrase);
//        break;
//      default:
//        log.warn("Unknown passphrase request use case: {}", context.getCurrentUseCase().name());
//    }
//  }
//
//  /**
//   * <p>
//   * Provide additional entropy to the device to reduce risk of hardware compromise</p>
//   *
//   * @param entropy Random bytes provided by a secure random number generator (see {@link #generateEntropy()}
//   */
//  public void provideEntropy(byte[] entropy) {
//
//    // Set the FSM context
//    context.continueCreateWallet_Entropy(entropy);
//
//  }
//
//  /**
//   * <p>Request an address from the device. The device will respond by providing an address calculated
//   * based on the <a href="https://en.bitcoin.it/wiki/BIP_0044">BIP-44</a> deterministic wallet approach from
//   * the master node.</p>
//   *
//   * <p>The BIP-44 chain code is arranged as follows:</p>
//   * <p><code>M/44'/coin type'/account'/key purpose/index</code></p>
//   * <p>Notes:</p>
//   * <ol>
//   * <li>Coin type is 0' for Bitcoin</li>
//   * <li>Account is 0-based and will be hardened when necessary (e.g. 0x80000000)</li>
//   * <li>Key purpose resolves as 0 for external (receiving), 1 for internal (change) but other values may come later</li>
//   * <li>Index is 0-based and identifies a particular address</li>
//   * </ol>
//   *
//   * @param account     The plain account number (0 gives maximum compatibility)
//   * @param keyPurpose  The key purpose (RECEIVE_FUNDS,CHANGE,REFUND,AUTHENTICATION etc)
//   * @param index       The plain index of the required address
//   * @param showDisplay True if the device should display the same address to allow the user to verify no tampering has occurred (recommended).
//   */
//  public void requestAddress(int account, KeyChain.KeyPurpose keyPurpose, int index, boolean showDisplay) {
//
//    // Set the FSM context
//    context.beginGetAddressUseCase(account, keyPurpose, index, showDisplay);
//
//  }
//
//  /**
//   * <p>Request a public key from the device. The device will respond by providing the public key calculated
//   * based on the <a href="https://en.bitcoin.it/wiki/BIP_0044">BIP-44</a> deterministic wallet approach from
//   * the master node.</p>
//   *
//   * <p>The BIP-44 chain code is arranged as follows:</p>
//   * <p><code>M/44'/coin type'/account'/key purpose/index</code></p>
//   * <p>Notes:</p>
//   * <ol>
//   * <li>Coin type is 0' for Bitcoin</li>
//   * <li>Account is 0-based and will be hardened when necessary (e.g. 0x80000000)</li>
//   * <li>Key purpose resolves as 0 for external (receiving), 1 for internal (change) but other values may come later</li>
//   * <li>Index is 0-based and identifies a particular address</li>
//   * </ol>
//   *
//   * @param account    The plain account number (0 gives maximum compatibility)
//   * @param keyPurpose The key purpose (RECEIVE_FUNDS,CHANGE,REFUND,AUTHENTICATION etc)
//   * @param index      The plain index of the required address
//   */
//  public void requestPublicKey(int account, KeyChain.KeyPurpose keyPurpose, int index) {
//
//    // Set the FSM context
//    context.beginGetPublicKeyUseCase(account, keyPurpose, index);
//
//  }
//
//  /**
//   * <p>Request a public key from the device for use with authentication. The device will respond by providing the public key calculated
//   * based on the <a href="https://en.bitcoin.it/wiki/BIP_0032">BIP-32</a> deterministic wallet approach from
//   * the master node.</p>
//   *
//   * <p>A BIP-32 chain code is derived from a combination of the URI and the index as follows:</p>
//   * <ol>
//   * <li>Concatenate the little endian representation of index with the URI (index + URI)</li>
//   * <li>Compute the SHA256 hash of the result (256 bits)</li>
//   * <li>Take first 128 bits of the hash and split it into four 32-bit numbers A, B, C, D</li>
//   * <li>Set highest bits of numbers A, B, C, D to 1</li>
//   * <li>Derive the hardened HD node m/13'/A'/B'/C'/D' according to BIP32 (e.g. bitwise-OR with 0x80000000)</li>
//   * </ol>
//   *
//   * @param identityUri    The identity URI (e.g. "https://user@multibit.org/trezor-connect")
//   * @param index          The index of the identity to use (default is zero) to allow for multiple identities on same path
//   * @param ecdsaCurveName The ECDSA curve name to use for TLS (e.g. "nist256p1") leave null to use default
//   * @param showDisplay    True if the result should only be given on the device display
//   */
//  public void requestPublicKeyForIdentity(URI identityUri, int index, String ecdsaCurveName, boolean showDisplay) {
//
//    if (Strings.isNullOrEmpty(ecdsaCurveName)) {
//      ecdsaCurveName = "nist256p1";
//    }
//
//    // Set the FSM context
//    context.beginGetPublicKeyForIdentityUseCase(identityUri, index, ecdsaCurveName, showDisplay);
//
//  }
//
//  /**
//   * <p>Request a deterministic hierarchy based on the given child numbers.</p>
//   *
//   * <p>This can be used to create a "watching wallet" that does not contain any private keys so long
//   * as all hardened child numbers are included.</p>
//   *
//   * @param childNumbers The list of child numbers representing a path that may include hardened entries
//   */
//  public void requestDeterministicHierarchy(List<ChildNumber> childNumbers) {
//
//    // Set the FSM context
//    context.beginGetDeterministicHierarchyUseCase(childNumbers);
//
//  }
//
//  /**
//   * <p>Request some data to be encrypted or decrypted using an address key from the device. The device will respond by providing
//   * the encrypted/decrypted data based on the key derived using the <a href="https://en.bitcoin.it/wiki/BIP_0044">BIP-44</a> deterministic
//   * wallet approach from the master node. <b>This data is unique to the seed phrase and is deterministic</b>.</p>
//   *
//   * <p>The BIP-44 chain code is arranged as follows:</p>
//   * <p><code>M/44'/coin type'/account'/key purpose/index</code></p>
//   * <p>Notes:</p>
//   * <ol>
//   * <li>Coin type is 0' for Bitcoin</li>
//   * <li>Account is 0-based and will be hardened when necessary (e.g. 0x80000000)</li>
//   * <li>Key purpose resolves as 0 for external (receiving), 1 for internal (change) but other values may come later</li>
//   * <li>Index is 0-based and identifies a particular address</li>
//   * </ol>
//   *
//   * @param account      The plain account number (0 gives maximum compatibility)
//   * @param keyPurpose   The key purpose (RECEIVE_FUNDS,CHANGE,REFUND,AUTHENTICATION etc)
//   * @param index        The plain index of the required address
//   * @param displayText  The cipher key shown to the user (e.g. "User message")
//   * @param keyValue     The key value (e.g. "[16 bytes of random data]")
//   * @param isEncrypting True if encrypting
//   * @param askOnDecrypt True if device should ask on decrypting
//   * @param askOnEncrypt True if device should ask on encrypting
//   */
//  public void requestCipherKey(
//    int account,
//    KeyChain.KeyPurpose keyPurpose,
//    int index,
//    byte[] displayText,
//    byte[] keyValue,
//    boolean isEncrypting,
//    boolean askOnDecrypt,
//    boolean askOnEncrypt
//  ) {
//
//    // Set the FSM context
//    context.beginCipherKeyUseCase(
//      account,
//      keyPurpose,
//      index,
//      displayText,
//      keyValue,
//      isEncrypting,
//      askOnDecrypt,
//      askOnEncrypt
//    );
//  }
//
//  /**
//   * <p>Request some data to be signed using an address key from the device. The device will respond by providing
//   * the signed data based on the key derived using the <a href="https://en.bitcoin.it/wiki/BIP_0044">BIP-44</a> deterministic
//   * wallet approach from the master node.</p>
//   *
//   * <p>The BIP-44 chain code is arranged as follows:</p>
//   * <p><code>M/44'/coin type'/account'/key purpose/index</code></p>
//   * <p>Notes:</p>
//   * <ol>
//   * <li>Coin type is 0' for Bitcoin</li>
//   * <li>Account is 0-based and will be hardened when necessary (e.g. 0x80000000)</li>
//   * <li>Key purpose resolves as 0 for external (receiving), 1 for internal (change) but other values may come later</li>
//   * <li>Index is 0-based and identifies a particular address</li>
//   * </ol>
//   *
//   * @param account    The plain account number (0 gives maximum compatibility)
//   * @param keyPurpose The key purpose (RECEIVE_FUNDS,CHANGE,REFUND,AUTHENTICATION etc)
//   * @param index      The plain index of the required address
//   * @param message    The message for signing
//   */
//  public void signMessage(int account, KeyChain.KeyPurpose keyPurpose, int index, byte[] message) {
//
//    // Set the FSM context
//    context.beginSignMessageUseCase(
//      account,
//      keyPurpose,
//      index,
//      message
//    );
//  }
//
//  /**
//   * <p>Request that the device signs the given transaction (limited number of inputs/outputs).</p>
//   *
//   * @param transaction             The transaction containing all the inputs and outputs
//   * @param receivingAddressPathMap The paths to the receiving addresses for this transaction keyed by input index
//   * @param changeAddressPathMap    The paths to the change address for this transaction keyed by Address
//   */
//  public void simpleSignTx(
//    Transaction transaction,
//    Map<Integer, ImmutableList<ChildNumber>> receivingAddressPathMap,
//    Map<Address, ImmutableList<ChildNumber>> changeAddressPathMap) {
//
//    throw new UnsupportedOperationException("Not yet supported. Use signTx instead.");
//
//  }
//
//  /**
//   * <p>Request that the device signs the given transaction (unlimited number of inputs/outputs).</p>
//   *
//   * @param transaction             The transaction containing all the inputs and outputs
//   * @param receivingAddressPathMap The paths to the receiving addresses for this transaction keyed by input index
//   * @param changeAddressPathMap    The paths to the change address for this transaction keyed by Address
//   */
//  public void signTx(Transaction transaction, Map<Integer, ImmutableList<ChildNumber>> receivingAddressPathMap, Map<Address, ImmutableList<ChildNumber>> changeAddressPathMap) {
//
//    // Set the FSM context
//    context.beginSignTxUseCase(transaction, receivingAddressPathMap, changeAddressPathMap);
//
//  }
//
//  /**
//   * <p>Request that the device encrypts the given message.</p>
//   *
//   * @param message The message for signing
//   */
//  public void encryptMessage(byte[] message) {
//
//    throw new UnsupportedOperationException("Not yet supported. Please raise an issue and consider offering a bounty.");
//
//  }
//
//  /**
//   * @return 32 bytes (256 bits) of entropy generated locally
//   */
//  public byte[] generateEntropy() {
//
//    // Initialize a secure random number generator using
//    // the OWASP recommended method
//    SecureRandom secureRandom;
//    try {
//      secureRandom = SecureRandom.getInstance("SHA1PRNG");
//    } catch (NoSuchAlgorithmException e) {
//      throw new IllegalArgumentException(e);
//    }
//
//    // Generate random bytes
//    byte[] bytes = new byte[32];
//    secureRandom.nextBytes(bytes);
//
//    return bytes;
//  }
//
//  /**
//   * <p>Request some identity data to be signed using an address key from the device. The device will respond by providing
//   * the signed data based on the key derived using the <a href="https://en.bitcoin.it/wiki/BIP_0044">BIP-44</a> deterministic
//   * wallet approach from the master node.</p>
//   *
//   * <p>Notes:</p>
//   * <ol>
//   * <li>Provide a hidden challenge as random data used as a nonce</li>
//   * <li></li>
//   * </ol>
//   *
//   * @param identity The identity information to sign
//   */
//  public void signIdentity(Identity identity) {
//
//    // Set the FSM context
//    context.beginSignIdentityUseCase(identity);
//  }
//

}
